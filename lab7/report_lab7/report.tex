\include{settings}

\begin{document}	% начало документа

% Титульная страница
\include{titlepage}

% Содержание
\include{ToC}


\section{Цель работы}
Изучение методов помехоустоqчивого кодирования и сравнение их свойств.

\section{Программа работы}
Провести кодирование/декодирование сигнала, полученного кодом Хэмминга 2-мя способами: с помощью встроенных функций encode/decode, а также через создание проверочной и генераторной матриц и вычисление синдрома. Оценить корректирующую способность кода.

Выполнить кодирование/декодирование циклическим кодом, кодом БЧХ. Оценить корректирующую способность кода.

\section{Теоретическая информация}
Помехоустойчивое кодирование — кодирование, предназначенное для передачи данных по каналам с помехами, обеспечивающее исправление возможных ошибок передачи вследствие помех.

Для обнаружения ошибок используют коды обнаружения ошибок, для исправления — помехоустойчивые коды.

При помехоустойчивом кодировании в поток передаваемых символов вводятся дополнительные (избыточные) символы для исправления возникающих на приемной стороне ошибок. Это требует увеличения скорости передачи по каналу, что при выбранном типе модема эквивалентно расширению полосы частот сигнала и уменьшению энергии посылки. Поэтому может возникнуть правомерный вопрос о целесообразности использования избыточного кодирования. На этот вопрос дает ответ теорема Шеннона о пропускной способности непрерывного канала связи, из которой следует, что пропускная способность непрерывного канала увеличивается с расширением его полосы, но при оптимальном (в широком смысле) кодировании. Поэтому следует ожидать повышения достоверности передачи при заданной скорости и отношении сигнал/шум в канале при внесении избыточности.

Тип кода определяет принцип, по которому вносятя избыточные символы. В простейшем случае, группе из k символов источника ставится в соответствие n символов, передаваемых по каналу. Такой код называется блочным и записывается условно как (n , k)-код. Возможно также использование непрерывных кодов, характеризующихся тем, что операции кодирования и декодирования производятся над непрерывной последовательностью символов без разбиения на блоки. Рассмотрим принципы помехоустойчивого кодирования на примере блочного двоичного кода. Если к символам источника добавляются избыточные символы, то код называют систематическим. Если группе информационных символов ставится в соответствие новая группа символов, передаваемая по каналу, в которой информационных символов в явном виде нет, то код называется неразделимым.

Циклические коды относятся к классу линейных. Поэтому для их построения достаточно знать порождающую матрицу.

К циклическим кодам относятся коды Хэмминга, которые являются одним из немногочисленных примеров совершенных кодов. Они имеют кодовое расстояние d= 3 и исправляют все одиночные ошибки. Длина кода выбирается из условия: $$2^{n-k} - 1 = n,$$ которое имеет простой смысл: число различных ненулевых синдромов равно числу символов в кодовой последовательности. Так, существуют коды Хэмминга $$( 2^r - 1, 2^r - r - 1 ),$$ в частности, коды: (7, 4), (15, 11), (31, 26), (63, 57) и т. д.

Среди циклических кодов широкое применение нашли коды Боуза— Чоудхури—Хоквингема (БЧХ). Можно показать, что для любых целых положительных чисел m и l< n/2 существует двоичный код БЧХ длины 
$$n=2^m−1 $$
с кодовым расстоянием d > 2l + 1, причем число проверочных символов (n−k)<=ml
. Для кодов БЧХ умеренной длины и ФМ при передаче символов можно добиться значительного выигрыша (4 дБ и более). Он достигается при скоростях (1/3 < k/n < 3/4). При очень высоких и очень низких скоростях выигрыш от кодирования существенно уменьшается.


\section{Ход выполнения работы}

\subsection{Листинг}

Были самостоятельно реализованны примеры для кода Хэмминга(4, 7)

\lstinputlisting[
	label=code:Hamming,
	caption={Hamming.py},% для печати символ '_' требует выходной символ '\'
]{Hamming.py}
\parindent=1cm % командна \lstinputlisting сбивает параментры отступа

Вывод программы

\begin{lstlisting}
message:  [1 0 1 0]
hamming code for this message:  [0, 1, 0, 0, 1, 0, 1]
syndrome for this code:  [0 0 0]
make mistake in 5 digit:  [0, 1, 0, 0, 0, 0, 1]
syndrome for code with error:  [1 0 1]
fix the mistake:  [0, 1, 0, 0, 1, 0, 1]
\end{lstlisting}

\lstinputlisting[
label=code:HammingMatrix,
caption={HammingMatrix.py},% для печати символ '_' требует выходной символ '\'
]{HammingMatrix.py}
\parindent=1cm % командна \lstinputlisting сбивает параментры отступа

Вывод программы

\begin{lstlisting}
message:  [[0 1 0 1]]
hamming code for this message:  [[0 1 0 1 0 1 0]]
syndrome for this code:  [[0 0 0]]
make mistake in 5 digit:  [[0 1 0 1 1 1 0]]
syndrome for code with error:  [[0 0 1]]
fix the mistake:  [[0 1 0 1 0 1 0]]
\end{lstlisting}

Была найдена готовая реализация циклического кодирования.

Результат реализации для примера 10111

\begin{lstlisting}
CyclicCode
-> Linear Block Code Cb( 7 , 3 )
-> Message length (k):              3
-> Codeword length (n):             7
-> Coding rate (R = k/n):           0.42857142857142855
-> Minimum Distance (dmin):         4
-> Error Detection Capability:      3
-> Error Correction Capability (t): 1
-> Weight Distribution (A):         [0 0 0 7 0 0 0]
-> Generator Matrix (G):

[[1 0 1 1 1 0 0]
[1 1 1 0 0 1 0]
[0 1 1 1 0 0 1]]

-> Parity Check Matrix (H):

[[1 0 0 0 1 1 0]
[0 1 0 0 0 1 1]
[0 0 1 0 1 1 1]
[0 0 0 1 1 0 1]]

-> Message Codeword Table:

Messages -> Codewords
[0 0 0] [0 0 0 0 0 0 0] m(X) = 0        c(X) = 0
[1 0 0] [1 0 1 1 1 0 0] m(X) = 1        c(X) = 1 + X^2 + X^3 + X^4
[0 1 0] [1 1 1 0 0 1 0] m(X) = X        c(X) = 1 + X + X^2 + X^5
[1 1 0] [0 1 0 1 1 1 0] m(X) = 1 + X    c(X) = X + X^3 + X^4 + X^5
[0 0 1] [0 1 1 1 0 0 1] m(X) = X^2      c(X) = X + X^2 + X^3 + X^6
[1 0 1] [1 1 0 0 1 0 1] m(X) = 1 + X^2  c(X) = 1 + X + X^4 + X^6
[0 1 1] [1 0 0 1 0 1 1] m(X) = X + X^2  c(X) = 1 + X^3 + X^5 + X^6
[1 1 1] [0 0 1 0 1 1 1] m(X) = 1 + X + X^2      c(X) = X^2 + X^4 + X^5 + X^6

-> Parity Check Equations:

c0 = m0 ⊕ m1
c1 = m1 ⊕ m2
c2 = m0 ⊕ m1 ⊕ m2
c3 = m0 ⊕ m2
c4 = m0
c5 = m1
c6 = m2

-> Syndrome Vector Equations:

s0 = r0 ⊕ r4 ⊕ r5
s1 = r1 ⊕ r5 ⊕ r6
s2 = r2 ⊕ r4 ⊕ r5 ⊕ r6
s3 = r3 ⊕ r4 ⊕ r6

-> Standard Array:

0000000 | 1011100 1110010 0101110 0111001 1100101 1001011 0010111 
-----------------------------------------------------------------
1000000 | 0011100 0110010 1101110 1111001 0100101 0001011 1010111 
0100000 | 1111100 1010010 0001110 0011001 1000101 1101011 0110111 
0010000 | 1001100 1100010 0111110 0101001 1110101 1011011 0000111 
0001000 | 1010100 1111010 0100110 0110001 1101101 1000011 0011111 
0000100 | 1011000 1110110 0101010 0111101 1100001 1001111 0010011 
0000010 | 1011110 1110000 0101100 0111011 1100111 1001001 0010101 
0000001 | 1011101 1110011 0101111 0111000 1100100 1001010 0010110 

-> Decoding Table:

Correctable Error Patterns -> Syndromes
[0 0 0 0 0 0 0] [0 0 0 0]
[1 0 0 0 0 0 0] [1 0 0 0]
[0 1 0 0 0 0 0] [0 1 0 0]
[0 0 1 0 0 0 0] [0 0 1 0]
[0 0 0 1 0 0 0] [0 0 0 1]
[0 0 0 0 1 0 0] [1 0 1 1]
[0 0 0 0 0 1 0] [1 1 1 0]
[0 0 0 0 0 0 1] [0 1 1 1]
\end{lstlisting}

Была найдена готовая реализация БЧХ кодирования.

Результат реализации для примера 110111

\begin{lstlisting}
BCHcode

Generator Polynomial:        g(X) = 1 + X^3 + X^5 + X^6 + X^8 + X^9 + X^10
Roots of g(X) in GF(2^5):    α^1, α^3 and all conjugate roots
Code length:                 n = 2^m - 1 = 31
Message length:              k = 21
Number of parity bits:       n - k = 10 <= mt
Minimum Hamming distance:    dmin = 7 >= 2t + 1
Error correction capability: t = 3


Decode the received polynomial:
r(X) = 1 + X + α^9*X^2 + X^3 + α^4*X^4 + X^5

The syndrome vector components are:
s_1 = r(α^1) = 1 + (α^1) + α^9*(α^1)^2 + (α^1)^3 + α^4*(α^1)^4 + (α^1)^5 = α^16
s_2 = r(α^2) = 1 + (α^2) + α^9*(α^2)^2 + (α^2)^3 + α^4*(α^2)^4 + (α^2)^5 = α^1
s_3 = r(α^3) = 1 + (α^3) + α^9*(α^3)^2 + (α^3)^3 + α^4*(α^3)^4 + (α^3)^5 = α^19
s_4 = r(α^4) = 1 + (α^4) + α^9*(α^4)^2 + (α^4)^3 + α^4*(α^4)^4 + (α^4)^5 = α^28
s_5 = r(α^5) = 1 + (α^5) + α^9*(α^5)^2 + (α^5)^3 + α^4*(α^5)^4 + (α^5)^5 = α^7
s_6 = r(α^6) = 1 + (α^6) + α^9*(α^6)^2 + (α^6)^3 + α^4*(α^6)^4 + (α^6)^5 = α^20

Therefore the syndrome polynomial is:
S(X) = α^16 + α^1*X + α^19*X^2 + α^28*X^3 + α^7*X^4 + α^20*X^5

The Euclidean algorithm is applied by constructing the following table:

i  ||   r_i = r_(i−2) − q_i * r_(i−1)  ||    q_i   ||    t_i = t_(i−2) − t_i * t_(i−1)
--------------------------------------------------------------------------------
-1 ||    X^6 ||          - ||    0
0 ||     α^16 + α^1*X + α^19*X^2 + α^28*X^3 + α^7*X^4 + α^20*X^5 ||      - ||    1
1 ||     α^14 + α^25*X + α^14*X^2 + α^5*X^3 + α^3*X^4 ||         α^29 + α^11*X ||        α^29 + α^11*X
2 ||     α^13 + α^28*X + α^19*X^2 + α^17*X^3 ||          α^28 + α^17*X ||        α^28 + α^30*X + α^28*X^2
3 ||     α^14 + α^27*X ||        α^17*X ||       α^29 + α^9*X + α^16*X^2 + α^14*X^3

When the degree of the polynomial in column r_i(X) is lower than the
degree of the polynomial in column t_i(X), the recursion is halted.
In this case:
r_3(X) = α^14 + α^27*X
t_3(X) = α^29 + α^9*X + α^16*X^2 + α^14*X^3

An element λ ∈ GF(32) is conveniently selected to multiply
t_i(X) by, in order to convert it into a monic polynomial.
This value of λ is λ = α^17
Therefore:

Error location polynomial:
σ(X) = λ * t_i(X) = α^17(α^29 + α^9*X + α^16*X^2 + α^14*X^3)
= α^15 + α^26*X + α^2*X^2 + X^3

σ'(X) = α^26 + α^4*X

Error evaluation polynomial:
W(X) = -λ * r_i(X) = α^17 * α^14 + α^27*X
= 1 + α^13*X

Performing Chien search in the error location polynomial σ(X):


Error values:

Error polynomial:
e(X) = 0

Code vector:
c = r + e = [ 1 26 10 21  5 30]
\end{lstlisting}

\section{Выводы}
В данной работе были изучены различные способы помехоустойчивого кодирования. Было установленно, что код Хэмминга может обнаружить и скорректировать меньшее колличесвто ошибок, чем другие коды, но при этом он требует меньшее колличество контрольных бит.
\end{document}
